{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"A GitHub &amp; PowerShell development framework","text":"<p>We empower PowerShell-savvy developers to effortlessly transform their ideas into impactful solutions. Our approach centers around a development framework that allows developers to focus on delivering value through their code. By leveraging the GitHub platform and PowerShell, we aim to automate the repetitive tasks, enabling developers \u2014 whether as consumers or contributors  \u2014 to concentrate on coding without distractions.</p>"},{"location":"#supported-platforms","title":"Supported Platforms","text":"<p>This development framework is built to serve the needs of modern developers and environments. We prioritize supporting the latest Long-Term Servicing (LTS) version of PowerShell to ensure that we can leverage the most recent features and capabilities, keeping our framework aligned with the demands of today\u2019s development landscape. We assume most of the users of this framework work on modern platforms and have access to the latest versions of PowerShell or seek to use it to develop solutions intended to run on modern systems, like GitHub Actions, Azure Functions on a developer machine.</p>"},{"location":"#the-trade-off-not-supporting-windows-powershell","title":"The Trade-Off: Not Supporting Windows PowerShell","text":"<p>We\u2019ve made a deliberate choice not to actively persure to support the older Windows PowerShell (5.1) version, as it limits our ability to use the newest PowerShell features. Where its low effort to support Windows PowerShell, we will do so, but we will not actively develop modules for it. While we recognize that some users may still rely on Windows PowerShell 5.1, they can run tools developed in this framework by installing PowerShell 7 alongside it or on remote systems. This decision ensures that this framework can focus on delivering new features for modern development without being constrained by legacy technology, which would otherwize require significant effort to develop and maintain, even if it is available in the newer versions of PowerShell.</p>"},{"location":"#products-and-projects-we-focus-on","title":"Products and projects we focus on","text":"<p>Our framework is dedicated to advancing the tools and processes that empower modern development and operations teams, with a specific focus on GitHub as our primary toolstack. We concentrate on the following key areas:</p> <ul> <li>PowerShell modules</li> <li>GitHub Actions and Workflows</li> <li>Serverless applications using Function Apps in Azure</li> </ul>"},{"location":"#powershell-modules","title":"PowerShell modules","text":"About  A PowerShell module is a set of functions, scripts, and cmdlets that are bundled together in a single package. Modules are used to organize and distribute code in a way that is easy to use and share. They can be used to extend the functionality of PowerShell, automate tasks, and create reusable code that can be shared with others. We have created a framework that automates the process of creating, testing, and publishing PowerShell modules to the PowerShell Gallery. This framework is designed to make it easy for developers to create and share their PowerShell modules with the community.   How we do it in PSModule  Projects based on the `Template-PSModule` repository template will automatically have the necessary workflows and configurations set up to automate the process of creating, testing, and publishing PowerShell modules to the PowerShell Gallery. This includes workflows for building, testing, and releasing the module, as well as a configuration file for setting up the module's metadata and dependencies. Using custom properties we set `RepoType` to `Module`. We use branch policies to control the flow of changes to the `main` branch, and we use labels to control the versioning of the module when a pull request is merged.   Create a new project  1. [Create a repository based on the template Template-PSModule](https://github.com/new?template_name=Template-PSModule&amp;template_owner=PSModule). The module will by default use the name of the repository. See [Process-PSModule](https://github.com/PSModule/Process-PSModule) for more info on choosing another name than the repository name. 1. Create a repository or organization secret called `APIKEY` holding the API key for the PowerShell Gallery. 1. Configure the settings you want for the repository including a branch policy for the `main` branch. 1. On a topic branch:    1. develop the code you want to add to your module.    1. delete the parts you do not need.    1. update the tests in the `tests` folder. 1. Create a PR. Add a label to the PR depending on what you want to do.    - `Major` - Will create a major release (vX.0.0) when merged. If specified with \"Prerelease\", a major version will be created using the prerelease tag (vX.0.0-\\).    - `Minor` - Will create a minor release (vX.Y.0) when merged. If specified with \"Prerelease\", a minor version will be created using the prerelease tag (vX.Y.0-\\).    - `Patch` - Will create a minor release (vX.Y.Z) when merged. If specified with \"Prerelease\", a minor version will be created using the prerelease tag (vX.Y.Z-\\). A patch version bump is the default if nothing is specified for the PR.    - `Prerelease` - CI will create a prerelease of the module using the branch name as a prerelease tag in the version. This will create both a repository release and a prerelease version of the module on the PowerShell Gallery. 1. Once the PR is created, the [Process-PSModule](https://github.com/PSModule/Process-PSModule) workflow will trigger. 1. When the PR is merged, a release will be created and the module will be published to the PowerShell Gallery with a stable version based on the version bump indicator the PR was was labeled with. Prerelease tags will be cleaned up on the repository.   Modules delivered on the PowerShell Gallery Name Description Version Admin A PowerShell module working with the admin role.              Ast A PowerShell module for using the Abstract Syntax Tree (AST) to analyze any PowerShell code.              AzureDevOps A PowerShell module to interact with the Azure DevOps REST API.              Base64 A PowerShell module that just handles base64 conversion and validation.              Bluesky A PowerShell module to interact with BlueSky              CasingStyle A PowerShell module that works with casing of text.              Confluence A PowerShell module that interacts with Atlassian Confluence              Context A PowerShell module that manages contexts with secrets and variables.              DateTime A PowerShell module to work with DateTime objects.              DeepSeek A PowerShell module to interact with DeepSeek              Discord A PowerShell module to interact with Discord.              DynamicParams A PowerShell module that makes it easier to use dynamic params.              Fonts A PowerShell module for managing fonts.              GitHub A PowerShell module to interact with GitHub, both interactively and via automation.              GoogleFonts A PowerShell module to download and install fonts from GoogleFonts.              GraphQL A PowerShell module to simplify working with a GraphQL APIs.              Guid A PowerShell module that makes working with GUID sligthly more PowerShelly              GZip A PowerShell Module that handles GZip archives              Hashtable A PowerShell module that simplifies some interaction with Hashtables.              IPv4 A PowerShell module for managing IPv4 data              Json A PowerShell module for typical Json related tasks.              Jwt A PowerShell module to help work with Json Web Tokens (JWTs)              LinkedIn A PowerShell module to programmatically interact with LinkedIn              Markdown A PowerShell module to handle markdown              MemoryMappedFile A PowerShell module that manages MemoryMappedFile              NerdFonts A PowerShell module to download and install fonts from NerdFonts.              Object A PowerShell module that manages Objects in PowerShell.              OpenAI A PowerShell module for interacting with OpenAI              Path A PowerShell module to manage the PATH environment variable on Windows.              PowerShellDataFile A PowerShell module for base functions...              PowerShellGallery A PowerShell module for interacting with the PowerShell Gallery.              PSCredential A Powershell module to manage PSCredentials              PSCustomObject A PowerShell module for missing functions of PSCustomObjects.              PSSemVer A PowerShell module adding a SemVer compatible class and functions.              PublicIP A PowerShell module that helps getting info about your public IP.              Retry A PowerShell module to create a retry mechanism around functions              Run A PowerShell module to manage native commands              Sodium A PowerShell module for handling Sodium encrypted secrets.              Telemetry A PowerShell module for managing and registering telemetry.              TimeSpan A PowerShell module for working with TimeSpans              Tls A module for working with TLS settings.              Twitch A PowerShell module for interacting with Twitch.              Uri A powershell module that works with URIs (RFC3986)              Utilities A PowerShell module with a collection of functions that should have been in PowerShell to start with.              WoW A PowerShell module containing utilities for World of Warcraft.              Yaml A PowerShell module for working with Yaml."},{"location":"#powershell-based-azure-function-apps","title":"PowerShell based Azure Function Apps","text":"About  A PowerShell based Azure Function App is a serverless compute service that enables you to run event-driven code without having to manage the infrastructure. Azure Functions are ideal for processing data, integrating systems, and building simple APIs or microservices. They can be triggered by a variety of events, such as HTTP requests, timers, or messages from Azure services like Azure Storage, Event Grid, or Service Bus. We have created a framework that automates the process of creating, testing, and deploying PowerShell based Azure Function Apps to Azure. This framework is designed to make it easy for developers to create and deploy their Azure Function Apps without having to worry about the underlying infrastructure.   How we do it in PSModule  Projects based on the `Template-FunctionApp` repository template will automatically have the necessary workflows and configurations set up to automate the process of creating, testing, and deploying PowerShell based Azure Function Apps to Azure. This includes workflows for building, testing, and deploying the function app, as well as a configuration file for setting up the function app's metadata and dependencies. Using custom properties we set `RepoType` to `FunctionApp`. We use branch policies to control the flow of changes to the `main` branch, and we use labels to control the versioning of the module when a pull request is merged.   Create a new project  1. Create a repository based on the template [Template-FunctionApp](https://github.com/PSModule/Template-FunctionApp). The module will by default use the name of the repository. 1. Create a repository or organization secret called `AZURE_CREDENTIALS`, holding the credentials for the Azure service principal. 1. Configure the settings you want for the repository including a branch policy for the `main` branch. 1. On a topic branch:    1. develop the code you want to add to your function app.    1. delete the parts you do not need.    1. update the tests in the `tests` folder. 1. Create a PR. Add a label to the PR depending on what you want to do.     - `Major` - Will create a major release (vX.0.0) when merged. If specified with \"Prerelease\", a major version will be created using the prerelease tag (vX.0.0-\\).     - `Minor` - Will create a minor release (vX.Y.0) when merged. If specified with \"Prerelease\", a minor version will be created using the prerelease tag (vX.Y.0-\\).     - `Patch` - Will create a minor release (vX.Y.Z) when merged. If specified with \"Prerelease\", a minor version will be created using the prerelease tag (vX.Y.Z-\\). A patch version bump is the default if nothing is specified for the PR.     - `Prerelease` - CI will create a prerelease of the module using the branch name as a prerelease tag in the version. This will create both a repository release and a prerelease version of the module on the PowerShell Gallery. 1. Once the PR is created, the [Process-FunctionApp](https://github.com/PSModule/Process-FunctionApp) workflow will trigger. 1. When the PR is merged, a release will be created and the function app will be deployed to Azure with a stable version based on the version bump indicator the PR was was labeled with. Prerelease tags will be cleaned up on the repository.   Function Apps we maintain Name Description Version GitHubApp              A GitHub app running on Azure Function App"},{"location":"#powershell-based-github-actions-composite-action","title":"PowerShell based GitHub Actions (composite action)","text":"About  A composite action is a reusable action that is made up of one or more steps. Composite actions can be used to encapsulate common tasks or workflows that can be reused across multiple repositories. They are a great way to share code and best practices with the community, and they can help to streamline the development process by providing a consistent way to perform common tasks. We have created a framework that automates the process of creating, testing, and publishing PowerShell based GitHub Actions to the GitHub Marketplace. This framework is designed to make it easy for developers to create and share their GitHub Actions with the community.   How we do it in PSModule  Projects are based on the `Template-Action` repository template will automatically have the necessary workflows and configurations set up to automate the process of creating, testing, and deploying PowerShell based Azure Function Apps to Azure. This includes workflows for building, testing, and deploying the function app, as well as a configuration file for setting up the function app's metadata and dependencies. Using custom properties we set `RepoType` to `FunctionApp`. We use branch policies to control the flow of changes to the `main` branch, and we use labels to control the versioning of the module when a pull request is merged.   Create a new project  1. Create a repository based on the template [Template-Action](https://github.com/PSModule/Template-Action).   GitHub Actions on the GitHub Marketplace Name Description Version Auto\u2011Configure              Autmates the configuration of a GitHub repo              Auto\u2011Document              Automatically creates documentation for actions and workflows              Auto\u2011Release              Automatically creates releases based on pull requests and labels.              Build\u2011PSModule              Action that is used to build a PowerShell module and it's manifest              Debug              Print info from the runner environment to logs              Document\u2011PSModule              A function that deals with creating module documentation with the PSModule flavor.              Download\u2011CIArtifact              Downloads an artifact from a CI workflow              Get\u2011IssueFormData              Get the data from a issue that was generated based on a issue form              Get\u2011PesterCodeCoverage              A GitHub action for gathering code coverage from a pester test              Get\u2011PesterTestResults              A GitHub Action that is used to gather testreulst for the PSModule process              GitHub\u2011Script              A GitHub Action used for running a PowerShell Script that uses the GitHub PowerShell module              Initialize\u2011PSModule              An action that is used to prepare the runner for PSModule framework.              Install\u2011PowerShell              A GitHub Action that installs a given version of PowerShell              Install\u2011PSModuleHelpers              A GitHub action that installs the PSModule library              Invoke\u2011Pester              A Pester-infused GitHub Action              Invoke\u2011ScriptAnalyzer              A GitHub Action that analyzes your PowerShell code using PSScriptAnalyzer.              Publish\u2011PSModule              Action that is used to publish a PowerShell module              Test\u2011PSModule              Test PowerShell modules with Pester and PSScriptAnalyzer."},{"location":"#reusable-workflows","title":"Reusable workflows","text":"About  Reusable workflows are a way to define a workflow in one repository and use it in multiple repositories. They can be used to automate common tasks, such as building, testing, and deploying code, and they can help to streamline the development process by providing a consistent way to perform these tasks across multiple repositories. We have created a framework that automates the process of creating, testing, and deploying reusable workflows in a organization. This framework is designed to make it easy for developers to create and share their workflows with the community.   How we do it in PSModule  Projects are based on the `Template-Workflow` repository template will automatically have the necessary workflows and configurations set up to automate the process of creating, testing, and deploying reusable workflows in a organization. This includes workflows for building, testing, and deploying the workflows, as well as a configuration file for setting up the workflows metadata and dependencies. Using custom properties we set `RepoType` to `Workflow`. We use branch policies to control the flow of changes to the `main` branch, and we use labels to control the versioning of the module when a pull request is merged.   Create a new project  1. Create a repository based on the template [Template-Workflow](https://github.com/PSModule/Template-Workflow).   Workflows we maintain Name Description Version Process\u2011PSModule              Process a module from source code to published module."},{"location":"About/","title":"About us","text":"<p>We are PSModule :)</p>"},{"location":"Blog/","title":"Blog","text":"<p>Welcome to the PSModule blog! Here you'll find the latest news, updates, and insights related to PowerShell + GitHub development.</p>"},{"location":"Blog/2024/01/31/test-blog-post/","title":"Test blog post","text":"<p>This is a test blog post.</p>","tags":["Foo","Bar"]},{"location":"GitHub-Actions/","title":"GitHub Actions","text":"<p>Action parameters:</p> <p>For nested actions we should be using unique names for the github action. The names of the action should be something like _INPUT"},{"location":"GitHub-Actions/Some-More/","title":"Some more","text":""},{"location":"GitHub-Actions/Test-Something/","title":"Test something","text":""},{"location":"GitHub-Actions/Subtopic/","title":"Subtopic","text":""},{"location":"GitHub-Actions/Subtopic/Some-More/","title":"Some more","text":""},{"location":"GitHub-Actions/Subtopic/Test-Something/","title":"Test something","text":""},{"location":"PowerShell-Modules/","title":"PowerShell","text":"<p>qweqwe</p>"},{"location":"PowerShell-Modules/Test-Specification/","title":"PowerShell Function Test Specification","text":""},{"location":"PowerShell-Modules/Test-Specification/#overview","title":"Overview","text":"<p>This document defines the structure and guidelines for writing Pester tests for PowerShell functions. The goal is to ensure consistency and comprehensive test coverage while maintaining clarity.</p>"},{"location":"PowerShell-Modules/Test-Specification/#test-structure","title":"Test Structure","text":"<p>Each function is tested within a structured Pester <code>Describe</code> block that follows this hierarchy:</p>"},{"location":"PowerShell-Modules/Test-Specification/#1-module-level-describe","title":"1. Module-Level <code>Describe</code>","text":"<ul> <li>The outermost <code>Describe</code> block corresponds to the module.</li> <li>The module name is derived from the prefix of the function name's noun part.</li> </ul>"},{"location":"PowerShell-Modules/Test-Specification/#2-function-level-describe","title":"2. Function-Level <code>Describe</code>","text":"<ul> <li>Each function within the module gets its own <code>Describe</code> block.</li> <li>Named using the full function name.</li> </ul>"},{"location":"PowerShell-Modules/Test-Specification/#3-use-case-context","title":"3. Use Case <code>Context</code>","text":"<ul> <li>Each use case is grouped within a <code>Context</code> block.</li> <li>The context name starts with the function name followed by a descriptive test case identifier.</li> <li>Example: <code>Get-Uri - simple usage</code></li> <li>Example: <code>Get-Uri - Pipeline usage</code></li> <li>Example: <code>Get-Uri - ParameterSet: Detailed</code></li> </ul>"},{"location":"PowerShell-Modules/Test-Specification/#4-functional-it-statements","title":"4. Functional <code>It</code> Statements","text":"<ul> <li>Each <code>It</code> block tests a specific aspect of the function's behavior.</li> <li>The name follows the format: <code>FunctionName - &lt;expected behavior&gt;</code></li> <li>Example: <code>Get-Uri - gets the URI object when provided a string</code></li> <li>Example: <code>Get-Uri - returns $null when input is empty</code></li> <li>Example: <code>Get-Uri - throws error on invalid input</code></li> </ul>"},{"location":"PowerShell-Modules/Test-Specification/#5-test-guidelines","title":"5. Test Guidelines","text":"<ul> <li>No Mocks: We do not use mocks in tests.</li> <li>Real Inputs: Tests should use actual inputs and expected outputs.</li> <li>Comprehensive Coverage: All function functionality, including edge cases, must be tested.</li> </ul>"},{"location":"PowerShell-Modules/Test-Specification/#example-test-structure","title":"Example Test Structure","text":"<pre><code>Describe 'Uri' {\n    Describe 'Get-Uri' {\n        Context 'Get-Uri - simple usage' {\n            It 'Get-Uri - gets the URI object when provided a string' {\n                $result = Get-Uri -InputString 'https://example.com'\n                $result | Should -BeOfType [System.Uri]\n            }\n        }\n\n        Context 'Get-Uri - Pipeline usage' {\n            It 'Get-Uri - processes input from the pipeline' {\n                $result = 'https://example.com' | Get-Uri\n                $result | Should -BeOfType [System.Uri]\n            }\n        }\n    }\n}\n</code></pre> <p>This ensures our tests are structured, maintainable, and adhere to best practices.</p>"},{"location":"PowerShell-Modules/Versioning/","title":"PowerShell Module Semantic Versioning Specification","text":""},{"location":"PowerShell-Modules/Versioning/#introduction","title":"Introduction","text":"<p>This document defines how changes to a PowerShell module\u2019s public interface determine updates to its version number under Semantic Versioning (SemVer). Semantic Versioning uses a three-part version format: MAJOR.MINOR.PATCH, where each part is incremented based on the nature of changes: - MAJOR version is incremented for incompatible API changes (breaking changes) (Semantic Versioning 2.0.0 | Semantic Versioning). - MINOR version is incremented for added functionality that is backward compatible (new features) (Semantic Versioning 2.0.0 | Semantic Versioning). - PATCH version is incremented for backward-compatible bug fixes or minor improvements (Semantic Versioning 2.0.0 | Semantic Versioning).</p> <p>In the context of a PowerShell module, the \u201cpublic API\u201d consists of all exported functions/cmdlets, public variables, classes, and enums that consumers of the module can use. Changes to these exported elements will dictate whether the version bump is major, minor, or patch. Internal changes that do not affect the exported interface are generally not reflected in the version. The following sections categorize changes and the required version update level, ensuring a consistent and predictable versioning strategy.</p>"},{"location":"PowerShell-Modules/Versioning/#major-version-x-breaking-changes","title":"Major Version (X) \u2013 Breaking Changes","text":"<p>A major version bump signifies a breaking change in the module\u2019s public interface. Any modification that could cause existing scripts or code relying on the module to fail or change behavior in an incompatible way requires incrementing the MAJOR version. These include:</p> <ul> <li> <p>Removal or Renaming of Exported Commands or Elements: Removing an exported function/cmdlet, variable, class, or enum, or renaming any of these, is a breaking change. Consumers referencing the old name will encounter errors because the item no longer exists or has a different name. (Example: <code>Get-ItemFoo</code> was exported in the previous version but is removed or renamed to <code>Get-FooItem</code> in the new version. Scripts calling <code>Get-ItemFoo</code> will break.) This kind of change must increment the major version to signal the break.</p> </li> <li> <p>Changes to Function Signatures: Modifying the signature of an exported function or cmdlet in a non-backward-compatible way triggers a major bump. This includes:</p> </li> <li>Removing a parameter from a function.</li> <li>Renaming a parameter (existing scripts using the old parameter name would fail).</li> <li>Changing the type of a parameter or the return type in a way that could break callers.</li> <li>Changing a parameter from optional to mandatory (or otherwise altering a default value in a way that requires callers to change how they call the function).</li> <li>Reordering parameters if it affects how the function is invoked positionally (though in PowerShell named parameters are common, positional changes can break scripts that rely on positional invocation).</li> <li>Any other modification to a function\u2019s definition that would make previously valid calls invalid. For example, if a new parameter is added without a default and thus is required, it would break calls that don\u2019t provide that parameter \u2013 this is a breaking change requiring a major version update (semantic versioning - Does adding a parameter to a function definition require a new major version? - Stack Overflow) (semantic versioning - Does adding a parameter to a function definition require a new major version? - Stack Overflow). (If the new parameter is optional, see Minor changes below.)</li> </ul> <p>Example: An exported function <code>Invoke-ProcessData -Path &lt;string&gt;</code> is changed to <code>Invoke-ProcessData -Uri &lt;string&gt;</code> (parameter renamed) or an existing parameter is removed. Scripts using the old parameter name or expecting that parameter will fail, hence a major version increment is needed.</p> <ul> <li>Breaking Changes to Exported Classes: If the module exports PowerShell classes (public classes meant for users to consume), any breaking change to those classes requires a major version bump. Breaking class changes include:</li> <li>Removing a public class or renaming a class.</li> <li>Removing or renaming public properties or methods of a class.</li> <li>Changing the signature of a class method (e.g. altering parameters or return type in an incompatible way).</li> <li>Changing property types or making a formerly public member non-public.</li> </ul> <p>Example: An exported class <code>FileClient</code> had a public property <code>Timeout</code> that is removed or renamed, or a method <code>Connect(string server)</code> is changed to <code>Connect(Uri server)</code>. Code instantiating <code>FileClient</code> or calling its methods would break, so the major version must increase.</p> <ul> <li>Breaking Changes to Exported Enums: Enums (enumerations) define a set of constant values. Changing them in a breaking way includes:</li> <li>Removing an enum type that was exported.</li> <li>Renaming an enum type or an enum member.</li> <li>Removing an existing value from an enum, or altering its name or meaning.</li> <li>Changing the underlying type of an enum (if relevant in PowerShell, e.g. from int to another type).</li> </ul> <p>Example: An exported enum <code>LogLevel</code> had members <code>Info, Warning, Error</code>. If <code>Warning</code> is removed or renamed to <code>Warn</code>, any script using <code>LogLevel.Warning</code> will break. Such a change mandates a major version bump. (Adding a new enum value is not breaking \u2013 see Minor changes.)</p> <ul> <li>Other Incompatible Changes: Any other change that alters the expected behavior or contract of the public API in a way that existing consumers would need to modify their code is considered breaking. For instance, if the module\u2019s behavior changes in an incompatible manner (like a function now throws an error in a scenario where it previously quietly succeeded, or an output format changes such that scripts parsing the output would fail), the change should be treated as a breaking change. In general, any removal or incompatible modification of functionality is a major change.</li> </ul> <p>Rationale: According to Semantic Versioning, introducing changes that are not backward compatible requires a major version increment (Semantic Versioning 2.0.0 | Semantic Versioning). By increasing the major version, we communicate to users that they may need to adjust their scripts due to breaking changes. This aligns with the principle that \u201cMAJOR version when you make incompatible API changes\u201d (Semantic Versioning 2.0.0 | Semantic Versioning). For example, if a function or parameter that existed in version 1.x is no longer present in version 2.0, that is an incompatible API change. Our versioning policy follows this rule strictly: breaking changes will never be introduced in a minor or patch release, ensuring that patch and minor updates can be safely adopted without fear of script-breaking surprises.</p>"},{"location":"PowerShell-Modules/Versioning/#minor-version-y-backward-compatible-additions","title":"Minor Version (Y) \u2013 Backward-Compatible Additions","text":"<p>A minor version bump is used for new features and additions that are backward compatible with the existing public API. These changes enhance the module\u2019s functionality without breaking any existing usage. In other words, existing scripts will continue to work as before, and new capabilities are introduced. Changes that trigger a MINOR version increase include:</p> <ul> <li> <p>Adding New Exported Functions/Cmdlets: Introducing a new function or cmdlet to the module is a backward-compatible addition. Since it does not remove or change existing functions, nothing breaks; users simply have an additional function available. Example: Adding a new cmdlet <code>New-Report</code> to the module (where it didn\u2019t exist before) would be a new feature. This warrants a minor version bump because it\u2019s an additive, non-breaking change.</p> </li> <li> <p>Adding New Parameters to Existing Functions: If you extend an existing function\u2019s capabilities by adding a new parameter in a way that does not break existing calls, it is a minor change. The key here is that the new parameter must be optional or have a default value such that any existing calls (which don\u2019t pass this parameter) still work exactly as before. In semantic versioning terms, this is adding functionality in a backwards-compatible manner (semantic versioning - Does adding a parameter to a function definition require a new major version? - Stack Overflow).</p> </li> <li>If the new parameter is optional (or has a sensible default), existing scripts can ignore it and will not be affected (semantic versioning - Does adding a parameter to a function definition require a new major version? - Stack Overflow). For example, adding an optional <code>-Force</code> switch or an optional <code>-TimeoutSeconds</code> parameter (with a default value) to a function is a minor update. Users can start using the new parameter if they want the new behavior, but all old usages remain valid.</li> <li> <p>Important: If a new parameter is added as required (with no default), that breaks existing calls (which would now be missing a required argument), and thus would be a breaking change requiring a major bump (semantic versioning - Does adding a parameter to a function definition require a new major version? - Stack Overflow). So, new parameters must be introduced in a backward-compatible way (optional or with defaults) to qualify as a minor version update.</p> </li> <li> <p>Adding New Exported Variables: If the module begins to export a new public variable (for example, a new preference variable or a constant) that wasn\u2019t present before, it\u2019s an additive change. Since no existing variable is removed or changed, existing scripts are unaffected (they simply might not use or know about the new variable). This constitutes a minor version increment. Example: Adding a new <code>$PublicConfig</code> variable that scripts can read is a new feature, bumped in the minor version.</p> </li> <li> <p>Adding New Classes or Members: Introducing a new public class (exported from the module) or adding new members to an existing exported class in a non-breaking way is a minor change:</p> </li> <li>Adding a brand new class (e.g., a helper class or a new type for users to utilize) doesn\u2019t impact existing code since nothing is removed or changed.</li> <li> <p>Adding a new method or property to an existing exported class can be considered backward compatible as long as it doesn\u2019t conflict with existing members. Existing scripts constructing or using the class will continue to work as before. (One caveat: if consumers have derived from this class, adding new abstract members would be breaking, but assuming typical usage where classes are used as-is, new members are just additional features.)   Example: A class <code>Connection</code> gains a new method <code>TestConnection()</code> in version 1.2. Previous scripts using <code>Connection</code> are not affected (they don\u2019t call the new method), but now have the option to use <code>TestConnection</code>. This is a minor feature addition.</p> </li> <li> <p>Adding New Enum Values or New Enums: If the module introduces a new enumeration type, or adds additional members to an existing enum, it\u2019s generally treated as a backward-compatible addition:</p> </li> <li>New Enum Type: Completely new enum (e.g., a new enum <code>Color</code> with values Red/Green/Blue) is additive.</li> <li> <p>New Value in Existing Enum: Adding a value to an existing exported enum can be viewed as a new feature. Code that doesn\u2019t know about the new value isn\u2019t forced to use it. (Existing switch statements or logic that enumerate enum values may not account for it, but they won\u2019t immediately break at runtime; however, developers should update their code to handle the new case if appropriate. Since it doesn\u2019t outright break compilation or invocation in PowerShell, it\u2019s considered backward compatible in this context.)   Example: The enum <code>LogLevel</code> had <code>Info, Warning, Error</code>. If we add <code>Verbose</code> as a new level in a minor release, existing scripts using <code>LogLevel</code> continue to run (they might not handle <code>Verbose</code> if encountered, but nothing crashes by the mere presence of the new value). It\u2019s an additive feature, hence a minor bump.</p> </li> <li> <p>Non-Breaking Changes to Existing Features: In some cases, a change might alter behavior but still be backward compatible. For instance, making an existing parameter accept a new type of input in addition to existing types (broadening what is accepted) could be considered a new capability that doesn\u2019t break old usage. Such changes can fall under minor version if they extend functionality without removal or contradiction of the old behavior. (However, caution is advised: changing behavior can sometimes surprise users. If in doubt, treat as major if it might disrupt assumptions.)</p> </li> </ul> <p>In summary, any new functionality that does not force existing users to change their usage is a candidate for a minor version increment (Semantic Versioning 2.0.0 | Semantic Versioning). Minor releases accumulate enhancements and new features, signalling to users that new capabilities are available, but all existing scripts should continue to work as they did in the previous version. Users can upgrade to the new minor version and gain new functions or options without needing to modify their existing code. This aligns with the SemVer guideline that \u201cMINOR version [increments] when you add functionality in a backward compatible manner\u201d (Semantic Versioning 2.0.0 | Semantic Versioning).</p>"},{"location":"PowerShell-Modules/Versioning/#patch-version-z-bug-fixes-and-improvements","title":"Patch Version (Z) \u2013 Bug Fixes and Improvements","text":"<p>A patch version bump is used for changes that do not affect the module\u2019s public API or add new features, but rather fix issues or improve internal implementation. Patch updates are meant to be safe, drop-in updates for users, with no risk of breaking functionality or changing how features are used. Scenarios for a PATCH version increment include:</p> <ul> <li>Bug Fixes: Correcting any bugs in existing functions or features, provided the fix does not alter the function\u2019s signature or expected input/output in a way that would break compatibility. The behavior might change (from incorrect to correct), but since the original behavior was unintended (a bug), this is considered a backward-compatible fix. For example:</li> <li>Fixing a logic error in a function so that it now produces the correct result.</li> <li>Correcting a typo in output or an error message.</li> <li> <p>Resolving a minor issue where an enum value wasn\u2019t handled in an internal function (assuming no public API change).   As long as the outward-facing contract remains the same (same function name, parameters, outputs), these are patch changes. Consumers might notice the bug is resolved, but they do not need to change their code \u2013 they just get the benefit of the fix.</p> </li> <li> <p>Performance Improvements: Optimizations that improve the performance or efficiency of the module without affecting the external behavior or API. For instance, rewriting an algorithm inside a function to run faster or use less memory, but with the same input/output interface and results, qualifies as a patch. Users\u2019 experience may improve (faster execution), but they don\u2019t need to change anything in their usage. This is a non-breaking internal improvement.</p> </li> <li> <p>Refactoring and Internal Cleanup: Changes to the internal code structure, organization, or quality that do not change any aspect of the public interface or observable behavior fall under patch (or possibly no version change at all \u2013 see the next section). If you release a new version that purely refactors code (improves maintainability, updates comments, reorganizes module files) and the module\u2019s exported functions and behavior remain identical, it can be considered a patch update. From the user\u2019s perspective, nothing changed functionally, so there\u2019s no new feature (hence not a minor) and no break (hence not a major). Releasing it as a patch version indicates it\u2019s a minor improvement or maintenance release.</p> </li> <li> <p>Documentation or Metadata Updates: If you publish a new version to update documentation included in the module (e.g., help content) or to adjust module metadata (like author info, tags, etc.) without any code change affecting functionality, this would be a patch version increment. (However, often documentation changes alone might not necessitate a new release; if they do, patch is appropriate since the API is unchanged.)</p> </li> </ul> <p>Note: A patch release should not introduce any new public surface area or change the meaning of anything in the public API. It is strictly for fixes and invisible improvements. According to SemVer rules, \u201cPATCH version when you make backwards-compatible bug fixes\u201d (Semantic Versioning 2.0.0 | Semantic Versioning) \u2013 this includes fixes and minor tweaks that do not affect compatibility. Users upgrading from one patch version to the next within the same minor series (e.g., 1.2.3 to 1.2.4) should notice no differences except the resolved issues or performance gains. They do not get new features (and thus don\u2019t need to learn anything new), and they do not have to worry about breaks.</p>"},{"location":"PowerShell-Modules/Versioning/#internal-changes-with-no-version-impact","title":"Internal Changes with No Version Impact","text":"<p>Certain changes do not require any version number increase at all, because they have no effect on the module\u2019s outward-facing behavior or interface. In a disciplined development practice, if the only changes in a commit or release are purely internal and produce no difference in functionality or API, the version can remain the same. In practice, such changes are often bundled with other changes or released as patch versions if needed. But as a guideline, metadata or refactoring changes that do not impact the exported interface should not influence the version number (they are essentially \u201cno-ops\u201d as far as the user is concerned). Examples:</p> <ul> <li> <p>Refactoring without Behavioral Changes: If the code is refactored (e.g., splitting a large function into smaller private helper functions, renaming internal variables, improving readability) but the exported functions, classes, and variables all behave exactly the same and have the same signatures, then there\u2019s no need for a version change. The module behaves identically from the consumer\u2019s perspective.</p> </li> <li> <p>Build System or Test Changes: Updates to the module\u2019s build scripts, continuous integration configuration, or test suite do not require a version bump. These are changes for the developers/maintainers and do not ship to the user in a way that affects usage.</p> </li> <li> <p>Metadata Updates: Changing non-functional metadata such as author name, project URL, licensing info, etc., in the module manifest (PSD1) doesn\u2019t affect how the module is used at runtime. Such changes alone don\u2019t merit a version increment.</p> </li> <li> <p>Formatting and Comments: Modifying code formatting, comments, or other non-executable parts of the code has no effect on functionality. No version change is needed for these kinds of modifications alone.</p> </li> <li> <p>No-Op Rebuilds: In some cases, a module might be rebuilt or repackaged without any code changes (for example, re-signing the module or packaging it differently). If the contents of the module\u2019s public API and behavior are unchanged, the version number should ideally remain the same. (If a rebuild must be published, one might use the same version or a patch if required by tooling, but from a semantic standpoint, nothing changed.)</p> </li> </ul> <p>In summary, if a change does not modify or add to the public interface and does not fix a user-facing bug, it should not cause any visible version change. The automated versioning scripts or maintainers should ignore such changes when determining how to bump the version. Essentially, purely internal changes = no bump (or at most a patch if a release is needed for some reason). This ensures the version number reflects meaningful changes that users care about.</p> <p>(Note: In practice, every release must have a unique version. So if you are releasing changes that have no API impact, you might still increment the patch to publish it. But the key is that those internal changes by themselves never escalate the version beyond patch, and if they are truly no-ops, you might choose not to release until there\u2019s a user-facing change.)</p>"},{"location":"PowerShell-Modules/Versioning/#versioning-strategy-and-update-expectations","title":"Versioning Strategy and Update Expectations","text":"<p>This module follows a \u201clatest version\u201d support strategy, meaning that only the most recent release is fully supported and maintained. When a new version is released, it supersedes previous versions. Older versions are not maintained, and users are expected to upgrade to the latest version to receive fixes and new features. As stated in Microsoft\u2019s guidance for PowerShell modules: \u201cOnly the latest major version receives full support, including new features, bug fixes, and updates. We strongly recommend upgrading to the latest version\u2026\u201d (Versioning, release cadence, and breaking changes - Microsoft Entra PowerShell | Microsoft Learn). In our context, this means:</p> <ul> <li> <p>We do not create maintenance releases for older major versions. For example, if the module is currently at 2.x, we will not typically release further updates for 1.x; any fixes or enhancements will go into a new 2.x (or later) release. The focus is on moving forward with the latest version of the module.</p> </li> <li> <p>Breaking changes will be introduced only with a major version bump, and when we do increment the major version, users should plan to update their scripts to accommodate those changes. Since older majors won\u2019t get back-ported fixes, upgrading is important to stay supported.</p> </li> <li> <p>Minor and patch releases are intended to be safe to adopt (no breaking changes). Users should feel confident updating to a new minor version within the same major series to get new features, and applying patch updates for bug fixes. Given that we don\u2019t maintain parallel old versions, applying these updates is the primary way to get issues resolved.</p> </li> <li> <p>Semantic versioning in this module serves as a contract with users: by looking at how the version changed, users can tell what to expect:</p> </li> <li>A major jump (e.g. 1.4.0 \u2192 2.0.0) signals \u201cThere are breaking changes; read the release notes and be prepared to adjust your usage.\u201d</li> <li>A minor jump (e.g. 2.3.5 \u2192 2.4.0) signals \u201cNew features have been added, but everything you used before still works.\u201d</li> <li>A patch jump (e.g. 2.4.0 \u2192 2.4.1) signals \u201cNo new features, but some issues were fixed or minor improvements made; nothing should break.\u201d</li> </ul> <p>By adhering to this strategy, we ensure clarity and consistency. Users who always upgrade to the latest version will benefit from all improvements and will only need to make script changes when a major version increments (which will be clearly indicated by the version number change).</p>"},{"location":"PowerShell-Modules/Versioning/#automated-version-bump-determination-implementation","title":"Automated Version Bump Determination (Implementation)","text":"<p>To enforce the above rules, we will use custom PowerShell scripts as part of our build/release process to automatically determine the appropriate version bump based on the changes in the module. The automation will compare the module\u2019s exported interface between the current release and the new version under development: - It will detect additions of public elements (functions, parameters, variables, classes, enum values) and detect removals or changes to public elements. - Based on this comparison, the script will decide the version increment:   - If new public functions, new optional parameters, or other new exported members are found (and no breaking changes), the script will set the version bump to Minor (since new functionality has been added in a backwards-compatible way).   - If any exported function/variable/class/enum from the previous version is missing in the new version, or a function\u2019s signature has changed incompatibly, etc., the script will flag a Major bump (since a breaking change was detected).   - If no differences in the public API are found (meaning no new features and no removed/changed features), then the changes must be purely fixes or internal improvements. In this case, the script will default to a Patch bump (PowerShell: Automatic Module Semantic Versioning).</p> <p>This approach mirrors the \u201cfingerprint\u201d strategy: generating a list (fingerprint) of all public API elements (e.g., <code>FunctionName:ParameterName</code> for each parameter of each function, plus entries for other exported members) for the current and previous version, and comparing them (PowerShell: Automatic Module Semantic Versioning) (PowerShell: Automatic Module Semantic Versioning). - If the new fingerprint has entries not present in the old fingerprint, those represent new capabilities (triggering a minor version increase) (PowerShell: Automatic Module Semantic Versioning). - If the old fingerprint has entries not present in the new fingerprint, those represent removed or changed items (triggering a major version increase) (PowerShell: Automatic Module Semantic Versioning). - If neither additions nor removals are detected, only patch-level changes exist (PowerShell: Automatic Module Semantic Versioning).</p> <p>Using automation ensures that our versioning rules are applied consistently on every release. However, we will also manually review changes for any subtleties that automation might miss. For example, a change in behavior that is technically backward-compatible in the API surface might still be communicated as a bigger change if it could impact users (the automation might view it as no API change, but maintainers might still choose to bump minor for a significant new behavior or even major if a fix alters expected outcomes in rare cases). The tooling serves as a baseline, and maintainers can override or augment the decision if necessary (but always adhering to the rule that breaking changes cannot be released under a non-major bump).</p> <p>Example of the automated logic in practice: Suppose in version 1.3.0 the module has a function <code>Get-Data -Path &lt;string&gt;</code> and in the development code we change this to <code>Get-Data -Path &lt;string&gt; -Filter &lt;string&gt;</code>, where <code>-Filter</code> is a new optional parameter. The script compares the exported interface: - Old version fingerprint might include an entry like <code>Get-Data:Path</code> for the parameter. - New version fingerprint includes <code>Get-Data:Path</code> and <code>Get-Data:Filter</code>. The new fingerprint has an entry not in the old (<code>Get-Data:Filter</code>), indicating a new parameter. The old fingerprint has none that the new lacks (we didn\u2019t remove anything; <code>Path</code> is still there). So the tool will identify a new feature addition with no removals, resulting in a Minor bump (1.4.0). This matches our expectation: adding an optional <code>-Filter</code> parameter is a backward-compatible enhancement.</p> <p>If instead we had removed <code>-Path</code> or renamed <code>Get-Data</code> to <code>Get-ItemData</code>, the old fingerprint would contain entries not in the new, flagging a breaking change. The script would then recommend a Major bump (to 2.0.0), aligning with our policy that such a removal/rename is breaking.</p> <p>If we only fixed a bug inside <code>Get-Data</code> but made no changes to its parameters or outputs, the fingerprints would be identical. The automation would not find any new or removed public element, and thus default to a Patch bump (1.3.1). This ensures even unseen internal changes result in at least a patch update if a release is made, but nothing more.</p>"},{"location":"PowerShell-Modules/Versioning/#conclusion","title":"Conclusion","text":"<p>This specification provides a clear framework for versioning a PowerShell module in accordance with Semantic Versioning principles, tailored to the specific elements of a PowerShell module\u2019s public interface. By classifying changes into major, minor, or patch categories, we ensure that the module\u2019s version number accurately communicates the impact of changes: - Major versions for breaking changes (removals, renames, incompatible alterations). - Minor versions for new features and additions that are backward compatible. - Patch versions for bug fixes and non-breaking improvements.</p> <p>Developers maintaining the module can use these guidelines to decide the appropriate version number for each release. Automated scripts will assist in detecting the scope of changes, but sound judgment will be applied in edge cases. Users of the module can rely on the version number to understand the significance of an update. Ultimately, this practice enables a predictable upgrade path where users only need to be concerned about potential breaking changes when the major version increases, and are otherwise free to take minor and patch updates confidently.</p> <p>By adhering to this specification, we uphold a contract of compatibility and improvement with our users, making module releases transparent and manageable in the long run.</p>"},{"location":"Solutions/","title":"Solutions","text":"<p>qweqwe</p>"},{"location":"Blog/archive/2024/","title":"2024","text":""},{"location":"Blog/category/test/","title":"test","text":""}]}